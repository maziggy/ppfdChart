// Import necessary modules from Lit using a CDN URL
import { LitElement, html, css } from 'https://unpkg.com/lit@2.0.0/index.js?module';

class PPFDCustomCard extends LitElement {
	// Define properties
	static properties = {
		entity: { type: String },
		title: { type: String },
		refresh_interval: { type: Number },
	};

	constructor() {
		super();
		this.entity = '';
		this.title = 'PPFD Chart';
		this.refresh_interval = 60;
		this.lastUpdateTimestamp = new Date();
		this.dli = null;
		this.lhd = null;
	}

	static styles = css`
		ha-card {
			padding: 15px;
			box-sizing: border-box;
		}
		.main-container {
			display: flex;
			align-items: center;
			width: 100%;
			color: #ffffff;
			background-color: #2c2c2e;
			border-radius: 10px;
			padding: 10px 10px;
			box-shadow: 2px 4px 10px rgba(0, 0, 0, 0.2);
			position: relative;
			box-sizing: border-box;
		}
		.main-container::before {
			content: "";
			position: absolute;
			top: -5px;
			left: -5px;
			right: -5px;
			bottom: -5px;
			border-radius: 12px;
			border: 1px solid rgba(100, 100, 255, 0.5);
			pointer-events: none;
			box-sizing: border-box;
		}
		.update-container {
			font-size: 0.8em;
			color: #ccc;
			padding-right: 10px;
			flex-shrink: 0;
			min-width: 90px;
			text-align: left;
		}
		.dli-display {
			font-size: 1em;
			color: #4CAF50;
			background: rgba(0, 0, 0, 0.7);
			padding: 5px 10px;
			border-radius: 5px;
			margin-top: 10px;
			box-shadow: 0px 2px 6px rgba(0, 0, 0, 0.3);
		}
		.chart-container {
			text-align: center;
			position: relative;
			width: 100%;
			padding: 0 10px;
			margin: 0 auto;
			box-sizing: border-box;
		}
		.section-names {
			display: flex;
			justify-content: space-between;
			width: 100%;
			top: -20px;
			font-size: 0.9em;
			color: #ffffff;
			padding: 0 10px;
			box-sizing: border-box;
			position: relative;
		}
		.chart-bar {
			width: 100%;
			height: 40px;
			top: -10px;
			position: relative;
			background: linear-gradient(to right, rgba(0, 9, 255, 1), rgba(4, 219, 190, 1), rgba(11, 230, 91, 1), rgba(255, 179, 0, 1), rgba(255, 3, 3, 1));
			border-radius: 20px;
			overflow: hidden;
			box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.2);
			margin-bottom: 10px;
		}
		.separator-vegetation {
			position: absolute;
			top: 0;
			bottom: 0;
			width: 2px;
			background-color: #333;
			opacity: 0.7;
			z-index: 10;
			left: calc((400 - 100) / 1100 * 100%); /* 400 is the start of Vegetation */
		}
		.separator-flowering {
			position: absolute;
			top: 0;
			bottom: 0;
			width: 2px;
			background-color: #333;
			opacity: 0.7;
			z-index: 10;
			left: calc((800 - 100) / 1100 * 100%); /* 800 is the start of Flowering */
		}
		.marker {
			position: absolute;
			display: flex;
			justify-content: center;
			align-items: center;
			width: 32px;
			height: 32px;
			background: radial-gradient(circle at center, #f1c40f 0%, #f39c12 70%);
			color: #222;
			font-weight: bold;
			font-size: 0.9em;
			border: 3px solid rgba(255, 235, 59, 0.8);
			border-radius: 50%;
			box-shadow: 0 0 10px rgba(255, 223, 0, 0.8), 0 0 6px rgba(0, 0, 0, 0.3);
			transform: translateX(-50%);
			text-align: center;
		}
		.scales {
			position: relative;
			font-size: 0.8em;
			color: #ffffff;
			width: 100%;
			box-sizing: border-box;
			display: flex;
			justify-content: space-between;
			padding-top: 4px;
		}
		.scale-tick {
			position: absolute;
			width: 1px;
			height: 10px;
			background-color: #ffffff;
			top: -10px;
			left: 50%;
			transform: translateX(-50%);
		}
		.scale-tick-label {
			position: absolute;
			transform: translateX(-50%);
			margin-top: 2px;
			font-size: 0.7em;
			color: #ccc;
		}
	`;

	set hass(hass) {
		this._hass = hass;
		const entityId = this.entity || 'input_text.grow_ppfd'; // Default to 'input_text.grow_ppfd' if not provided in config

		if (!entityId) {
			console.error("Entity ID is missing in the configuration.");
			return;
		}

		// Check if the entity exists in the state
		if (hass.states[entityId]) {
			const entityState = hass.states[entityId];

			if (!entityState) {
				console.error(`Entity ${entityId} not found in Home Assistant states.`);
				return;
			}

			console.log(`Entity state fetched: ${entityState.state}`);

			const currentPPFD = parseFloat(entityState.state);
			const lastUpdated = new Date(entityState.last_changed);

			// Ensure that shadowRoot is initialized before updating PPFD
			if (this.shadowRoot) {
				this.updateCurrentPPFD(currentPPFD);
				this.updateLastUpdated(lastUpdated);
				this.lastUpdateTimestamp = lastUpdated;

				// Calculate DLI
				this.calculateDLI(currentPPFD);
			} else {
				console.warn("shadowRoot is not yet available. Skipping update for now.");
			}
		} else {
			console.warn(`Entity ${entityId} state is not available. Check entity ID and Home Assistant state.`);
		}

		// Initialize the update interval if it doesn't exist and shadowRoot is available
		if (!this._interval && this.shadowRoot) {
			this._interval = setInterval(() => this.updateTimeSinceLastUpdate(), 1000);
		}
	}

	// Function to update the current PPFD marker position and value
	updateCurrentPPFD(currentPPFD) {
		if (!this.shadowRoot) return;

		const marker = this.shadowRoot.querySelector(".marker");
		const chartBar = this.shadowRoot.querySelector(".chart-bar");

		if (!chartBar) return;

		clearTimeout(this._throttleTimeout);
		this._throttleTimeout = setTimeout(() => {
			const minPPFD = 100;
			const maxPPFD = 1200;
			const barWidth = chartBar.offsetWidth;

			let position = ((currentPPFD - minPPFD) / (maxPPFD - minPPFD)) * barWidth;
			position = Math.max(0, Math.min(position, barWidth));

			if (marker) {
				marker.style.left = `${position}px`;
				marker.innerText = `${currentPPFD}`;

				// Add an onclick event to open the more-info dialog
				marker.onclick = () => {
					const event = new Event('hass-more-info', { bubbles: true, composed: true });
					event.detail = { entityId: this.entity };
					this.dispatchEvent(event);
				};
			}
		}, 100);
	}

	updateLastUpdated(lastUpdated) {
		if (!this.shadowRoot) return;
		const lastUpdatedElement = this.shadowRoot.querySelector("#update-time");

		// Set lastUpdateTimestamp without logging
		this.lastUpdateTimestamp = lastUpdated;
		this.updateTimeSinceLastUpdate();
	}

	updateTimeSinceLastUpdate() {
		if (!this.shadowRoot || !this.lastUpdateTimestamp) return;

		const lastUpdatedElement = this.shadowRoot.querySelector("#update-time");
		const now = new Date();

		// Calculate difference in seconds and add a sanity check
		const secondsAgo = Math.floor((now - this.lastUpdateTimestamp) / 1000);

		// If time difference is unrealistic, set display text to "Just now"
		if (secondsAgo < 0 || secondsAgo > 86400 * 365 * 5) { // 5 years as arbitrary max
			lastUpdatedElement.innerText = "Just now";
			return;
		}

		// Calculate the appropriate time display
		let displayText;

		if (secondsAgo < 60) {
			displayText = `${secondsAgo} seconds ago`;
		} else if (secondsAgo < 3600) {
			const minutesAgo = Math.floor(secondsAgo / 60);
			displayText = `${minutesAgo} minutes ago`;
		} else if (secondsAgo < 86400) {
			const hoursAgo = Math.floor(secondsAgo / 3600);
			displayText = `${hoursAgo} hours ago`;
		} else {
			const daysAgo = Math.floor(secondsAgo / 86400);
			displayText = `${daysAgo} days ago`;
		}

		if (lastUpdatedElement) {
			lastUpdatedElement.innerText = displayText;
		}
	}

	calculateDLI(currentPPFD) {
        	const onTimeEntity = this._hass.states['time.growbox_light_scheduled_on_time'];
	        const offTimeEntity = this._hass.states['time.growbox_light_scheduled_off_time'];

	        if (onTimeEntity && offTimeEntity) {
	            const onTime = new Date(`1970-01-01T${onTimeEntity.state}`);
        	    let offTime = new Date(`1970-01-01T${offTimeEntity.state}`);

	            if (offTime <= onTime) {
        	        offTime.setHours(offTime.getHours() + 24);
	            }

        	    const lightDurationMs = offTime - onTime;
	            this.lhd = Math.round(lightDurationMs / (1000 * 60 * 60));

        	    this.dli = Math.round((currentPPFD * this.lhd * 3600) / 1000000);

	            const dliDisplayElement = this.shadowRoot.querySelector("#dli-display");
        	    if (dliDisplayElement) {
	        	    dliDisplayElement.innerText = `DLI ${this.dli} @${this.lhd}h`;
        	    }
	        } else {
        	    console.warn("Scheduled light-on or light-off time entity is missing.");
	        }
	}

	render() {
		return html`
			<ha-card>
				<div class="main-container">
					<div class="update-container">
						<div><a href="https://github.com/maziggy/ppfdChart/" target=_blank style="text-decoration: none; color: inherit;"><u><b>ppfdChart</u></b></a></div>
						<div>Last Changed:<br><span id="update-time">Just now</span></div>
						<div class="dli-display" id="dli-display">Calculating...</div>
					</div>
					<div class="chart-container">
						<div class="section-names">
							<span class="section-seeding">Seeding</span>
							<span class="section-vegetation">Vegetation</span>
							<span class="section-flowering">Flowering</span>
						</div>
						<div class="chart-bar">
							<div class="separator-vegetation"></div>
							<div class="separator-flowering"></div>
							<div class="marker">0</div>
						</div>
						<div class="scales">
							${[100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200].map(value => html`
								<span class="scale-tick-label" style="left: ${(value - 100) / 11}%;">${value}</span>
								<div class="scale-tick" style="left: ${(value - 100) / 11}%;"></div>
							`)}
						</div>
					</div>
				</div>
			</ha-card>
		`;
	}

	setConfig(config) {
		if (!config.entity) {
			throw new Error('You need to define an entity');
		}
		this.entity = config.entity;
		this.title = config.title || 'PPFD Chart';
		this.refresh_interval = config.refresh_interval || 60;
	}
}

// Register the custom card
customElements.define('ppfd-custom-card', PPFDCustomCard);
