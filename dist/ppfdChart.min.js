import { LitElement, html, css } from 'https://unpkg.com/lit@2.0.0/index.js?module';

class PPFDCustomCard extends LitElement {
    static properties = {
        entity: { type: Number },
        light_off_entity: { type: Date },
        light_on_entity: { type: Date },
        title: { type: String },
        refresh_interval: { type: Number },
    };

    constructor() {
        super();
        this.entity = '';
        this.light_off_entity = '';
        this.light_on_entity = '';
        this.title = 'PPFD Chart';
        this.refresh_interval = 3600;
        this.lastUpdateTimestamp = new Date();
        this.dli = null;
        this.lhd = null;
    }

    static styles = css`
        ha-card {
            padding: 15px;
            box-sizing: border-box;
        }
        .main-container {
            display: flex;
            align-items: center;
            width: 100%;
            color: #ffffff;
            background-color: #2c2c2e;
            border-radius: 10px;
            padding: 10px 10px;
            box-shadow: 2px 4px 10px rgba(0, 0, 0, 0.2);
            position: relative;
            box-sizing: border-box;
        }
        .update-container {
            font-size: 0.8em;
            color: #ccc;
            padding-right: 10px;
            flex-shrink: 0;
            min-width: 90px;
            text-align: left;
        }
        .dli-display {
            font-size: 1em;
            color: #4CAF50;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            margin-top: 10px;
            box-shadow: 0px 2px 6px rgba(0, 0, 0, 0.3);
        }
        .chart-container {
            text-align: center;
            position: relative;
            width: 100%;
            padding: 0 10px;
            margin: 0 auto;
            box-sizing: border-box;
        }
        .section-names {
            display: flex;
            justify-content: space-between;
            width: 100%;
            top: -20px;
            font-size: 0.9em;
            color: #ffffff;
            padding: 0 50px;
            box-sizing: border-box;
            position: relative;
        }
        .chart-bar {
            width: 100%;
            height: 40px;
            top: -10px;
            position: relative;
            background: linear-gradient(to right, rgba(0, 9, 255, 1), rgba(4, 219, 190, 1), rgba(11, 230, 91, 1), rgba(255, 179, 0, 1), rgba(255, 3, 3, 1));
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.2);
            margin-bottom: 10px;
            cursor: pointer;
        }
        .separator-vegetation {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #333;
            opacity: 0.7;
            z-index: 10;
            left: calc((400 - 100) / 1100 * 100%);
        }
        .separator-flowering {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #333;
            opacity: 0.7;
            z-index: 10;
            left: calc((800 - 100) / 1100 * 100%);
        }
        .marker {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 32px;
            height: 32px;
            background: radial-gradient(circle at center, #f1c40f 0%, #f39c12 70%);
            color: #222;
            font-weight: bold;
            font-size: 0.9em;
            border: 3px solid rgba(255, 235, 59, 0.8);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 223, 0, 0.8), 0 0 6px rgba(0, 0, 0, 0.3);
            transform: translateX(-50%);
            text-align: center;
        }
        .scales {
            position: relative;
            font-size: 0.8em;
            color: #ffffff;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            padding-top: 4px;
        }
        .scale-tick {
            position: absolute;
            width: 1px;
            height: 10px;
            background-color: #ffffff;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
        }
        .scale-tick-label {
            position: absolute;
            transform: translateX(-50%);
            margin-top: 2px;
            font-size: 0.7em;
            color: #ccc;
        }
    `;

    set hass(hass) {
        this._hass = hass;
        const entityId = this.entity || 'input_number.ppfdchart_ppfd';
        const light_off_entity = this.light_off_entity || 'time.growbox_light_scheduled_off_time';
        const light_on_entity = this.light_on_entity || 'time.growbox_light_scheduled_on_time';

        if (!entityId) {
            console.error("Entity ID is missing in the configuration.");
            return;
        }

        const entityState = hass.states[entityId];
        const light_off_state = hass.states[light_off_entity];
        const light_on_state = hass.states[light_on_entity];

        if (!entityState) {
            console.error(`Entity ${entityId} not found in Home Assistant states.`);
            return;
        }
        if (!light_off_state) {
            console.error(`Entity ${light_off_entity} not found in Home Assistant states.`);
            return;
        }
        if (!light_on_state) {
            console.error(`Entity ${light_on_entity} not found in Home Assistant states.`);
            return;
        }

        const currentPPFD = parseFloat(entityState.state);
        const lastUpdated = new Date(entityState.last_changed);

        if (this.shadowRoot) {
            this.updateCurrentPPFD(currentPPFD);
            this.updateLastUpdated(lastUpdated);
            this.lastUpdateTimestamp = lastUpdated;

            this.calculateDLI(currentPPFD, light_on_state, light_off_state);
        } else {
            console.warn("shadowRoot is not yet available. Skipping update for now.");
        }

        if (!this._interval && this.shadowRoot) {
            this._interval = setInterval(() => this.updateTimeSinceLastUpdate(), 1000);
        }
    }

    calculateDLI(currentPPFD, onTimeEntity, offTimeEntity) {
        if (onTimeEntity && offTimeEntity) {

            const onTime = new Date(`1970-01-01T${onTimeEntity.state}`);
            let offTime = new Date(`1970-01-01T${offTimeEntity.state}`);

            if (offTime <= onTime) {
                offTime.setHours(offTime.getHours() + 24);
            }

            const lightDurationMs = offTime - onTime;
            this.lhd = Math.round(lightDurationMs / (1000 * 60 * 60));
            this.dli = Math.round((currentPPFD * this.lhd * 3600) / 1000000);

            const dliDisplayElement = this.shadowRoot.querySelector("#dli-display");
            if (dliDisplayElement) {
                dliDisplayElement.innerText = `DLI ${this.dli} @${this.lhd}h`;            }
        } else {
            console.warn("Scheduled light-on or light-off time entity is missing.");
        }
    }

    updateCurrentPPFD(currentPPFD) {
        if (!this.shadowRoot) return;

        const marker = this.shadowRoot.querySelector(".marker");
        const chartBar = this.shadowRoot.querySelector(".chart-bar");

        if (!chartBar) return;

        clearTimeout(this._throttleTimeout);
        this._throttleTimeout = setTimeout(() => {
            const minPPFD = 100;
            const maxPPFD = 1200;
            const barWidth = chartBar.offsetWidth;

            let position = ((currentPPFD - minPPFD) / (maxPPFD - minPPFD)) * barWidth;
            position = Math.max(0, Math.min(position, barWidth));

            if (marker) {
                marker.style.left = `${position}px`;
                marker.innerText = `${currentPPFD}`;
                marker.onclick = () => this._showMoreInfo(this.entity);
            }
        }, 100);
    }

    updateLastUpdated(lastUpdated) {
        if (!this.shadowRoot) return;
        const lastUpdatedElement = this.shadowRoot.querySelector("#update-time");

        this.lastUpdateTimestamp = lastUpdated;
        this.updateTimeSinceLastUpdate();
    }

    updateTimeSinceLastUpdate() {
        if (!this.shadowRoot || !this.lastUpdateTimestamp) return;

        const lastUpdatedElement = this.shadowRoot.querySelector("#update-time");
        const now = new Date();
        const secondsAgo = Math.floor((now - this.lastUpdateTimestamp) / 1000);
        let displayText;

        if (secondsAgo < 60) {
            displayText = `${secondsAgo} seconds ago`;
        } else if (secondsAgo < 3600) {
            displayText = `${Math.floor(secondsAgo / 60)} minutes ago`;
        } else if (secondsAgo < 86400) {
            displayText = `${Math.floor(secondsAgo / 3600)} hours ago`;
        } else {
            displayText = `${Math.floor(secondsAgo / 86400)} days ago`;
        }

        if (lastUpdatedElement) {
            lastUpdatedElement.innerText = displayText;
        }
    }

    render() {
        return html`
            <ha-card>
                <div class="main-container">
                    <div class="update-container"}">
                        <div><a href="https://github.com/maziggy/ppfdChart/" target=_blank style="text-decoration: none; color: inherit;"><u><b>ppfdChart</u></b></a></div>
                        <div>Last Changed:<br><span id="update-time">Just now</span></div>
                        <div class="dli-display" id="dli-display"}">Calculating...</div>
                    </div>
                    <div class="chart-container">
                        <div class="section-names">
                            <span class="section-seeding">Seeding</span>
                            <span class="section-vegetation">Vegetation</span>
                            <span class="section-flowering">Flowering</span>
                        </div>
                        <div class="chart-bar" @click="${() => this._showMoreInfo(this.entity)}">
                            <div class="separator-vegetation"></div>
                            <div class="separator-flowering"></div>
                            <div class="marker">0</div>
                        </div>
                        <div class="scales">
                            ${[100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200].map(value => html`
                                <span class="scale-tick-label" style="left: ${(value - 100) / 11}%;">${value}</span>
                                <div class="scale-tick" style="left: ${(value - 100) / 11}%;"></div>
                            `)}
                        </div>
                    </div>
                </div>
            </ha-card>
        `;
    }

    setConfig(config) {
        if (!config.entity) {
            throw new Error('You need to define an entity');
        }
        this.entity = config.entity;
        this.title = config.title || 'PPFD Chart';
        this.refresh_interval = config.refresh_interval || 60;
    }

    _showMoreInfo(entityId) {
        const event = new Event('hass-more-info', { bubbles: true, composed: true });
        event.detail = { entityId };
        this.dispatchEvent(event);
    }
}

customElements.define('ppfd-custom-card', PPFDCustomCard);
