// Import necessary modules from Lit using a CDN URL
import { LitElement, html, css } from 'https://unpkg.com/lit@2.0.0/index.js?module';

class PPFDCustomCard extends LitElement {
    // Define properties
    static properties = {
        entity: { type: String },
        title: { type: String },
        refresh_interval: { type: Number },
    };

    constructor() {
        super();
        this.entity = '';
        this.title = 'PPFD Chart';
        this.refresh_interval = 60;
        this.lastUpdateTimestamp = new Date();
        this.dli = null;
        this.lhd = null;
    }

    static styles = css`
        ha-card {
            padding: 15px;
            box-sizing: border-box;
        }
        .main-container {
            display: flex;
            align-items: center;
            width: 100%;
            color: #ffffff;
            background-color: #2c2c2e;
            border-radius: 10px;
            padding: 10px 10px;
            box-shadow: 2px 4px 10px rgba(0, 0, 0, 0.2);
            position: relative;
            box-sizing: border-box;
        }
        .update-container {
            font-size: 0.8em;
            color: #ccc;
            padding-right: 10px;
            flex-shrink: 0;
            min-width: 90px;
            text-align: left;
        }
        .dli-display {
            font-size: 1em;
            color: #4CAF50;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            margin-top: 10px;
            box-shadow: 0px 2px 6px rgba(0, 0, 0, 0.3);
        }
        .chart-container {
            text-align: center;
            position: relative;
            width: 100%;
            padding: 0 10px;
            margin: 0 auto;
            box-sizing: border-box;
        }
        .section-names {
            display: flex;
            justify-content: space-between;
            width: 100%;
            font-size: 0.9em;
            color: #ffffff;
            padding: 0 10px;
            box-sizing: border-box;
            position: relative;
        }
        .chart-bar {
            width: 100%;
            height: 40px;
            position: relative;
            background: linear-gradient(to right, rgba(0, 9, 255, 1), rgba(4, 219, 190, 1), rgba(11, 230, 91, 1), rgba(255, 179, 0, 1), rgba(255, 3, 3, 1));
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.2);
            margin-bottom: 10px;
        }
        .separator {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #333;
            opacity: 0.7;
            z-index: 10;
        }
        .separator:nth-child(1) { left: calc((600 - 100) / 1100 * 100%); }
        .separator:nth-child(2) { left: calc((800 - 100) / 1100 * 100%); }
        .marker {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 32px;
            height: 32px;
            background: radial-gradient(circle at center, #f1c40f 0%, #f39c12 70%);
            color: #222;
            font-weight: bold;
            font-size: 0.9em;
            border: 3px solid rgba(255, 235, 59, 0.8);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 223, 0, 0.8), 0 0 6px rgba(0, 0, 0, 0.3);
            transform: translateX(-50%);
            text-align: center;
        }
        .scales {
            position: relative;
            font-size: 0.8em;
            color: #ffffff;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            padding-top: 4px;
        }
        .scale-tick {
            position: absolute;
            width: 1px;
            height: 10px;
            background-color: #ffffff;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
        }
        .scale-tick-label {
            position: absolute;
            transform: translateX(-50%);
            margin-top: 2px;
            font-size: 0.7em;
            color: #ccc;
        }
        .section-vegetation {
            position: absolute;
            left: 54%; /* Adjusted rightward */
            transform: translateX(-50%);
            font-size: 0.9em;
            color: #ffffff;
        }
    `;

    setConfig(config) {
        if (!config.entity) {
            throw new Error('You need to define an entity');
        }
        this.entity = config.entity;
        this.title = config.title || 'PPFD Chart';
        this.refresh_interval = config.refresh_interval || 60;
    }

    set hass(hass) {
        this._hass = hass;
        const entityId = this.entity;
        if (!entityId) {
            console.error("Entity ID is missing in the configuration.");
            return;
        }

        if (hass.states[entityId] && this.shadowRoot) {
            const entityState = hass.states[entityId];
            if (!entityState) {
                console.error(`Entity ${entityId} not found in Home Assistant states.`);
                return;
            }

            const currentPPFD = parseFloat(entityState.state);
            const lastUpdated = new Date(entityState.last_changed);

            this.updateCurrentPPFD(currentPPFD);
            this.updateLastUpdated(lastUpdated);
            this.lastUpdateTimestamp = lastUpdated;

            this.calculateDLI(currentPPFD);
        } else {
            console.warn("ShadowRoot or entity state is not available.");
        }

        if (!this._interval && this.shadowRoot) {
            this._interval = setInterval(() => this.updateTimeSinceLastUpdate(), 1000);
        }
    }

    updateCurrentPPFD(currentPPFD) {
        if (!this.shadowRoot) return;
        const marker = this.shadowRoot.querySelector(".marker");
        const chartBar = this.shadowRoot.querySelector(".chart-bar");

        const minPPFD = 100;
        const maxPPFD = 1200;
        const barWidth = chartBar ? chartBar.offsetWidth : 0;

        let position = ((currentPPFD - minPPFD) / (maxPPFD - minPPFD)) * barWidth;
        position = Math.max(0, Math.min(position, barWidth));

        if (marker) {
            marker.style.left = `${position}px`;
            marker.innerText = `${currentPPFD}`;
        }
    }

    updateLastUpdated(lastUpdated) {
        if (!this.shadowRoot) return;
        const lastUpdatedElement = this.shadowRoot.querySelector("#update-time");
        this.lastUpdateTimestamp = lastUpdated;
        this.updateTimeSinceLastUpdate();
    }

    updateTimeSinceLastUpdate() {
        if (!this.shadowRoot || !this.lastUpdateTimestamp) return;

        const lastUpdatedElement = this.shadowRoot.querySelector("#update-time");
        const now = new Date();
        const secondsAgo = Math.floor((now - this.lastUpdateTimestamp) / 1000);

        let displayText;

        if (secondsAgo < 60) {
            displayText = `${secondsAgo} seconds ago`;
        } else if (secondsAgo < 3600) {
            const minutesAgo = Math.floor(secondsAgo / 60);
            displayText = `${minutesAgo} minutes ago`;
        } else {
            const hoursAgo = Math.floor(secondsAgo / 3600);
            displayText = `${hoursAgo} hours ago`;
        }

        if (lastUpdatedElement) {
            lastUpdatedElement.innerText = displayText;
        }
    }

    calculateDLI(currentPPFD) {
        const onTimeEntity = this._hass.states['time.growbox_light_scheduled_on_time'];
        const offTimeEntity = this._hass.states['time.growbox_light_scheduled_off_time'];

        if (onTimeEntity && offTimeEntity) {
            const onTime = new Date(`1970-01-01T${onTimeEntity.state}`);
            let offTime = new Date(`1970-01-01T${offTimeEntity.state}`);

            if (offTime <= onTime) {
                offTime.setHours(offTime.getHours() + 24);
            }

            const lightDurationMs = offTime - onTime;
            this.lhd = Math.round(lightDurationMs / (1000 * 60 * 60));

            this.dli = Math.round((currentPPFD * this.lhd * 3600) / 1000000);

            const dliDisplayElement = this.shadowRoot.querySelector("#dli-display");
            if (dliDisplayElement) {
                dliDisplayElement.innerText = `DLI ${this.dli} @${this.lhd}h`;
            }
        } else {
            console.warn("Scheduled light-on or light-off time entity is missing.");
        }
    }

    render() {
        return html`
            <ha-card>
                <div class="main-container">
                    <div class="update-container">
                        <div><a href="https://github.com/maziggy/ppfdChart/" target=_blank style="text-decoration: none; color: inherit;"><u><b>ppfdChart</u></b></a></div>
                        <div>Last Changed:<br><span id="update-time">Just now</span></div>
                        <div class="dli-display" id="dli-display">Calculating...</div>
                    </div>
                    <div class="chart-container">
                        <div class="section-names">
                            <span class="section-seeding">Seeding</span>
                            <span class="section-vegetation">Vegetation</span>
                            <span class="section-flowering">Flowering</span>
                        </div>
                        <div class="chart-bar">
                            <div class="separator"></div>
                            <div class="separator"></div>
                            <div class="marker">0</div>
                        </div>
                        <div class="scales">
                            ${[100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200].map(value => html`
                                <span class="scale-tick-label" style="left: ${(value - 100) / 11}%;">${value}</span>
                                <div class="scale-tick" style="left: ${(value - 100) / 11}%;"></div>
                            `)}
                        </div>
                    </div>
                </div>
            </ha-card>
        `;
    }
}

// Register the custom card
customElements.define('ppfd-custom-card', PPFDCustomCard);
